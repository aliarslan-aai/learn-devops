----------------------------
Working with Shell - Basic
----------------------------
Linux shell allows user to interact with the OS
You can navigate b/w multiple locations
each user has his own personal dir under /home with r/w access
~ represent the home directory, e.g: ~ --> /home/elmo

uptime: how long the system has been up

Command in linux are of two types:
1. internal / built-in (part of shell, bundled with it)
    cd, pwd, echo, set, type
2. external (binary progs in the system) - preinstalled or user-installed
    mv, date, uptime, cp

pwd: present working dir
ls: see contents - List Storage
    -l: long list
    -a: hidden files
    -lt: long list in order created
    -ltr: reverse order of -lt
mkdir: make dir
mkdir -p: make dir recuresive
cd: change dir

Types of paths
absolute path: path all the way from root
relative path: path relative to pwd

pushd: pwd is saved to top of dir stack
popd: pops dir from top of dir stack

mv SRC DST: move file or dir
cp SRC DST: copy file
cp -r SRC DST: copy dir

rm: remove file or dir

cat FILE: concatenate cmd: displays content of the file
cat > FILE: writes contents to file (CTRL D TO EXIT THE EDITOR)
cat >> FILE: appends contents to file (CTRL D TO EXIT THE EDITOR)
touch FILE: create an empty file

Pagers:-
more FILE: displays one screen at a time (loads the whole file, not good >> files)
    ENTER: scrolls one line
    b: one screen back / page up
    /: search text
less FILE: displays one screen at a time
    up arrow: scrolls one row up
    down arrow: scrolls one row down
    /: search text

Getting help:
whatis CMD: one line description of a cmd
man CMD: manual page for command - detailed
some commands also provide --help as args
apropos KEYWORD: search for instances of a keyword in man pages

Shell types:- All used to interact with the OS
Bourne Shell (sh):
C Shell (csh or tsch):
Korn Shell (ksh):
Z shell (zsh):
Bourne again shell (bash): default mostly

chsh: change shell

alias dt=date: creates an alias to a command

env: lists all environment variables
export OFFICE=devCorps: creates a new environment variable / modifies
    will be available to all progs started by shell
export PATH=$PATH:/abc/xyz: appends a path to PATH
OFFICE=devCorps: creates a new environment variable / modifies
    only available to shell itself, not to progs started in shell
for persistence, add export commands to ~/.profile or ~/.pam_environment
PS1="elmo:" : sets the variable that holds string to display at each new line

---------------------
LINUX CORE CONCEPTS
---------------------
Linux Kernel:
-------------
Kernel: core interface b/w hardware and applications/processes

responsible for:
    mem mngmnt
    process mngment
    device drivers
    sys calls and security

linux kernel is monolithic
- carries out cpu schedualing, mem mngment by itself
minux kernel is modular
- need more info ???

uname: kernel
uname -r: kernel version

Mem Mngmnt:
divided into two:
- kernel space
    the space it uses to execute & provide its services
    a process running in kernel has unrestricted access to h/w
- user space
    applications. e.g. progs written in C++, java, Go
    user apps make requests to kernel for h/w access
        - open a file
        - write a file
        - list processes
        - define a variable

Working with hardware:
------------------------
dmesg: read sys logs generated by h/w
udevadm
lspci
lsblk
lscpu
lsmem
lsmem --summary
free -m
lshw

* total physical cores = Threads per core x Cores per socket

Linux boot Sequence:
----------------------
Process has 4 steps:
1. BIOS POST
    power on self-test
    - ensures h/w components attached to device are functioning properly
2. Boot Loader (GRUB2)
    loads & excecutes the boot device - located in first sector of boot device
    - in linux, in the /boot
3. Kernel Initialization
    after the selected kernel is loaded into the memory
    it is generally decompressed, then loaded to memory
    and starts processesing such as harward and mem mngmnt tasks
4. INIT Process (systemd)
    sets ups the user space & the processes needed in the user env
    then calls systemd deamon
    - this systemd is responsible for bringing linux host to a usable state
    - responsible for mounting file systems
    - starting & managing system services
    - to see which INIT process is used: ls -l /sbin/init

Runlevels
-----------
5 -> graphical (display manager service enabled)
3 -> CLI (display manager service disabled)

runlevel -> display run level
systemctl get-default  : view systemd target
systemctl set-default multi-user.target  : change systemd target
other is graphical.target

FileTypes
-----------
everything is a file is file
there are three types:
1. Regular file - images script, configs, data
2. directory - stores other files within
3. special files - 5 sub categories
    1. Character Files - devices under /dev filesystem
            mouse, keyboard
    2. Block files - devices under /dev
        read from and writes to devices in block files
        hard disk, ram
    3. Links - associate 2 or more filenames to the same file data
        two types:
            soft/sym/symbolic link: pointers to another file
                like shortcuts in windows
                deleting a symlink does not delelte the block of data
            hard link: 2 or more filenames that share the same block of data
                deleting one link will delete the data
    4. Sockers Files - communication b/w two processes
    5. named pipes - allows connecting one process as an input to another process
        data flow is uni-directional from first process to the second
How to identify the file type?
    use the "file ARG" cmd
    ls -l ARG
        from the output look at the first character
            d - directory
            - - Regular
            c - character device
            l - link
            s - socket file
            p - pipe
            b - block device

Filesystem Hierarchy
----------------------
/home - for all users except root
/root - home for root user
/opt - 3rd party apps
/mnt - mount filesystems temporarily in the system
/tmp - used to store temporary data
/media - external media devices
    df -hP : prints info about all the mounted filesystems
/dev - character files
/bin - basic prog binaries, cp, mv, mkdir, date etc
/etc - !!! most of configs
/lib, /lib64 - shared libs
/usr - old systems for user home - modern systems all user apps data
/var - logs for system, also has cached data

---------------------
PACKAGE MANAGEMENT
---------------------
RPM -> RHEL, Centos, Fedora
DEB -> Ubuntu, Debian, Linux Mint

DPKG Debian Package Manager
APT Advanced Package Manager
APT-GET Advanced Package Manager
RPM RedHat Package manager
YUM yellowdog update modifier
DNF

RPM vs YUM
-----------
RedHat Package manager
.rpm file extension
5 ops:
1. install     rpm -ivh telnet.rpm
2. uninstall   rpm -e telnet.rpm
3. upgrade     rpm -Uvh telnet.rpm
4. query       rpm -q telnet.rpm
5. verifying   rpm -Vf <path_to_file>

* RPM does not resolve package dependencies on its own, so we need YUM
* YUM uses RPM under the hood

yum stores repo info at /etc/yum.repos.d/*.repo

yum install -y httpd
yum repolist - displays all repos added to the system
yum provides scp - check which repo provides scp
yum remove httpd
yum update telnet - updates a single package
yum update - updates all packages

DPKG vs APT
-------------
DPKG Debian package manager
5 ops:
1. install/upgrade     dpkg -i telnet.rpm
2. uninstall           dpkg -r telnet.rpm
3. list                dpkg -l telnet.rpm
4. status              dpkg -s telnet.rpm
5. verifying           dpkg -p <path_to_file>

* DPKG does not resolve package dependencies on its own, so we need APT
* APT uses DPKG under the hood

DPKG stores sources info at /etc/apt/sources.list

apt update - refresh all repos
apt upgarde - upgrades exisint packages
apt edit-sources - opens /etc/apt/sources.list in editor
apt install telnet
apt remove telnet
apt search telnet
apt list | grep telnet

APT vs APT-GET
----------------
APT is more user friendly
APT has more user friendly output
APT can be used to search a package
we need apt-cache to search if we use apt-get


-------------------------------
Working with Shell - Advanced
-------------------------------

File Compression
------------------
du : disk usage
    -k kilobytes
    -h human readable
    -l long output - more verbose
    -s short output

tar : tape archive
    c – create a archive file.
    x – extract a archive file.
    v – show the progress of archive file.
    f – filename of archive file.
    t – viewing content of archive file.
    j – filter archive through bzip2.
    z – filter archive through gzip.
    r – append or update files or directories to existing archive file.
    W – Verify a archive file.
    wildcards – Specify patterns in unix tar command.

Compression Tools:
    bzip2 - uncrompress by bunzip2
    gzip  - uncrompress by gunzip
    xz    - uncrompress by unxz
zcat, bzcat, xzcat - allow reading compressed files without uncompressing

tar -cf python.tar reptile/snake/python
gzip python.tar

Searching Files and directories
---------------------------------
locate xyz.txt
- depends on mlocate db
- run updatedb to update mlocate

find /home/elmo -name Bunny.txt

grep - find something in file
grep second sample.txt
grep -i capital sample.txt - case-insensitive
grep -r "third line" /home/elmo - recursively look for a pattern within a directory
grep -v "printed" sample.txt - all lines that do not contain the specified string
grep -w exam examples.txt - looks for "exam" as a whole word
grep -A1 Arsenal prem-league.txt - also print one line after the match
grep -B3 Arsenal prem-league.txt - also print three lines before the match

IO Redirection
----------------
Standard streams:
1. Standard Input stdin
    takes text as input
2. Standard Output - stdout
3. Standard Error - stderror

> can be redirected to files
STDOUT
echo @SHELL > shell.txt - writes stdout to file
echo @SHELL2 >> shell.txt - appends stdout to file
STDERR
echo @SHELL 2> shell.txt - writes stderr to file
echo @SHELL 2>> shell.txt - appends stderr to file
echo @SHELL 2> /dev/null - ignore and does not print errors
*/dev/null is the bit bucket - a place to dump anything

> command line pipes
allows first commands stdout to be used as stdin of second command
pipes are defined using vertical bar symbol
    e.g: grep Hello sample.txt | less
tee - prints but also overwrites to file
    e.g: grep Hello sample.txt | tee shell.txt - print & overwrite file
    e.g: grep Hello sample.txt | tee -a shell.txt - print & append to file

> vi editor
VI Editing commands
    i - Insert at cursor (goes into insert mode)
    a - Write after cursor (goes into insert mode)
    A - Write at the end of line (goes into insert mode)
    ESC - Terminate insert mode
    u - Undo last change
    U - Undo all changes to the entire line
    o - Open a new line (goes into insert mode)
    dd - Delete line
    d3d - Delete 3 lines.
    D - Delete contents of line after the cursor
    C - Delete contents of a line after the cursor and insert new text. Press ESC key to end insertion.
    dw - Delete word
    4dw - Delete 4 words
    cw - Change word
    x - Delete character at the cursor
    r - Replace character
    R - Overwrite characters from cursor onward
    s - Substitute one character under cursor continue to insert
    S - Substitute entire line and begin to insert at the beginning of the line
    ~ - Change case of individual character
    yy - copy a line
    p - paste
    /line or ?line - seach line in file and move to first occurance
        n - to go to next occurance
        N - to go to previous occurance
    alt+j - move slected block down
    alt+k - move selected block up
Moving within a file
    k - Move cursor up
    j - Move cursor down
    h - Move cursor left
    l - Move cursor right
Saving and Closing the file
    ZZ - Save the file and quit
    :w - Save the file but keep it open
    :q - Quit without saving
    :wq - Save the file and quit
    :q! - Quit without confirmation

> vim = VI Improved
